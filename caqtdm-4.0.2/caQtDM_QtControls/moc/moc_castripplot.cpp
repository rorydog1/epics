/****************************************************************************
** Meta object code from reading C++ file 'castripplot.h'
**
** Created by: The Qt Meta Object Compiler version 67 (Qt 5.5.1)
**
** WARNING! All changes made in this file will be lost!
*****************************************************************************/

#include "../src/castripplot.h"
#include <QtCore/qbytearray.h>
#include <QtCore/qmetatype.h>
#if !defined(Q_MOC_OUTPUT_REVISION)
#error "The header file 'castripplot.h' doesn't include <QObject>."
#elif Q_MOC_OUTPUT_REVISION != 67
#error "This file was generated using the moc from 5.5.1. It"
#error "cannot be used with the include files from this version of Qt."
#error "(The moc has changed too much.)"
#endif

QT_BEGIN_MOC_NAMESPACE
struct qt_meta_stringdata_caStripPlot_t {
    QByteArrayData data[95];
    char stringdata0[1125];
};
#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_caStripPlot_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )
static const qt_meta_stringdata_caStripPlot_t qt_meta_stringdata_caStripPlot = {
    {
QT_MOC_LITERAL(0, 0, 11), // "caStripPlot"
QT_MOC_LITERAL(1, 12, 15), // "ShowContextMenu"
QT_MOC_LITERAL(2, 28, 0), // ""
QT_MOC_LITERAL(3, 29, 6), // "update"
QT_MOC_LITERAL(4, 36, 15), // "timerThreadStop"
QT_MOC_LITERAL(5, 52, 7), // "TimeOut"
QT_MOC_LITERAL(6, 60, 13), // "TimeOutThread"
QT_MOC_LITERAL(7, 74, 16), // "canvasBackground"
QT_MOC_LITERAL(8, 91, 10), // "autoReplot"
QT_MOC_LITERAL(9, 102, 5), // "Title"
QT_MOC_LITERAL(10, 108, 6), // "TitleX"
QT_MOC_LITERAL(11, 115, 6), // "TitleY"
QT_MOC_LITERAL(12, 122, 12), // "channelsList"
QT_MOC_LITERAL(13, 135, 8), // "channels"
QT_MOC_LITERAL(14, 144, 5), // "units"
QT_MOC_LITERAL(15, 150, 6), // "period"
QT_MOC_LITERAL(16, 157, 11), // "refreshRate"
QT_MOC_LITERAL(17, 169, 8), // "cpuUsage"
QT_MOC_LITERAL(18, 178, 9), // "XaxisType"
QT_MOC_LITERAL(19, 188, 9), // "xAxisType"
QT_MOC_LITERAL(20, 198, 14), // "numberOfXticks"
QT_MOC_LITERAL(21, 213, 9), // "YAxisType"
QT_MOC_LITERAL(22, 223, 9), // "yAxisType"
QT_MOC_LITERAL(23, 233, 12), // "YAxisScaling"
QT_MOC_LITERAL(24, 246, 12), // "yAxisScaling"
QT_MOC_LITERAL(25, 259, 16), // "YaxisLimitsMax_1"
QT_MOC_LITERAL(26, 276, 16), // "YaxisLimitsMin_1"
QT_MOC_LITERAL(27, 293, 17), // "YaxisScalingMax_1"
QT_MOC_LITERAL(28, 311, 11), // "axisScaling"
QT_MOC_LITERAL(29, 323, 17), // "YaxisScalingMin_1"
QT_MOC_LITERAL(30, 341, 7), // "Style_1"
QT_MOC_LITERAL(31, 349, 9), // "curvStyle"
QT_MOC_LITERAL(32, 359, 7), // "color_1"
QT_MOC_LITERAL(33, 367, 16), // "YaxisLimitsMax_2"
QT_MOC_LITERAL(34, 384, 16), // "YaxisLimitsMin_2"
QT_MOC_LITERAL(35, 401, 17), // "YaxisScalingMax_2"
QT_MOC_LITERAL(36, 419, 17), // "YaxisScalingMin_2"
QT_MOC_LITERAL(37, 437, 7), // "Style_2"
QT_MOC_LITERAL(38, 445, 7), // "color_2"
QT_MOC_LITERAL(39, 453, 16), // "YaxisLimitsMax_3"
QT_MOC_LITERAL(40, 470, 16), // "YaxisLimitsMin_3"
QT_MOC_LITERAL(41, 487, 17), // "YaxisScalingMax_3"
QT_MOC_LITERAL(42, 505, 17), // "YaxisScalingMin_3"
QT_MOC_LITERAL(43, 523, 7), // "Style_3"
QT_MOC_LITERAL(44, 531, 7), // "color_3"
QT_MOC_LITERAL(45, 539, 16), // "YaxisLimitsMax_4"
QT_MOC_LITERAL(46, 556, 16), // "YaxisLimitsMin_4"
QT_MOC_LITERAL(47, 573, 17), // "YaxisScalingMax_4"
QT_MOC_LITERAL(48, 591, 17), // "YaxisScalingMin_4"
QT_MOC_LITERAL(49, 609, 7), // "Style_4"
QT_MOC_LITERAL(50, 617, 7), // "color_4"
QT_MOC_LITERAL(51, 625, 16), // "YaxisLimitsMax_5"
QT_MOC_LITERAL(52, 642, 16), // "YaxisLimitsMin_5"
QT_MOC_LITERAL(53, 659, 17), // "YaxisScalingMax_5"
QT_MOC_LITERAL(54, 677, 17), // "YaxisScalingMin_5"
QT_MOC_LITERAL(55, 695, 7), // "Style_5"
QT_MOC_LITERAL(56, 703, 7), // "color_5"
QT_MOC_LITERAL(57, 711, 16), // "YaxisLimitsMax_6"
QT_MOC_LITERAL(58, 728, 16), // "YaxisLimitsMin_6"
QT_MOC_LITERAL(59, 745, 17), // "YaxisScalingMax_6"
QT_MOC_LITERAL(60, 763, 17), // "YaxisScalingMin_6"
QT_MOC_LITERAL(61, 781, 7), // "Style_6"
QT_MOC_LITERAL(62, 789, 7), // "color_6"
QT_MOC_LITERAL(63, 797, 16), // "YaxisLimitsMax_7"
QT_MOC_LITERAL(64, 814, 16), // "YaxisLimitsMin_7"
QT_MOC_LITERAL(65, 831, 17), // "YaxisScalingMax_7"
QT_MOC_LITERAL(66, 849, 17), // "YaxisScalingMin_7"
QT_MOC_LITERAL(67, 867, 7), // "Style_7"
QT_MOC_LITERAL(68, 875, 7), // "color_7"
QT_MOC_LITERAL(69, 883, 10), // "foreground"
QT_MOC_LITERAL(70, 894, 10), // "background"
QT_MOC_LITERAL(71, 905, 10), // "scaleColor"
QT_MOC_LITERAL(72, 916, 4), // "grid"
QT_MOC_LITERAL(73, 921, 9), // "gridColor"
QT_MOC_LITERAL(74, 931, 12), // "XaxisEnabled"
QT_MOC_LITERAL(75, 944, 12), // "YaxisEnabled"
QT_MOC_LITERAL(76, 957, 13), // "LegendEnabled"
QT_MOC_LITERAL(77, 971, 14), // "XaxisSyncGroup"
QT_MOC_LITERAL(78, 986, 3), // "Low"
QT_MOC_LITERAL(79, 990, 6), // "Medium"
QT_MOC_LITERAL(80, 997, 4), // "High"
QT_MOC_LITERAL(81, 1002, 7), // "Channel"
QT_MOC_LITERAL(82, 1010, 4), // "User"
QT_MOC_LITERAL(83, 1015, 5), // "Lines"
QT_MOC_LITERAL(84, 1021, 9), // "FillUnder"
QT_MOC_LITERAL(85, 1031, 11), // "Millisecond"
QT_MOC_LITERAL(86, 1043, 6), // "Second"
QT_MOC_LITERAL(87, 1050, 6), // "Minute"
QT_MOC_LITERAL(88, 1057, 10), // "ValueScale"
QT_MOC_LITERAL(89, 1068, 9), // "TimeScale"
QT_MOC_LITERAL(90, 1078, 12), // "TimeScaleFix"
QT_MOC_LITERAL(91, 1091, 6), // "linear"
QT_MOC_LITERAL(92, 1098, 5), // "log10"
QT_MOC_LITERAL(93, 1104, 10), // "fixedScale"
QT_MOC_LITERAL(94, 1115, 9) // "autoScale"

    },
    "caStripPlot\0ShowContextMenu\0\0update\0"
    "timerThreadStop\0TimeOut\0TimeOutThread\0"
    "canvasBackground\0autoReplot\0Title\0"
    "TitleX\0TitleY\0channelsList\0channels\0"
    "units\0period\0refreshRate\0cpuUsage\0"
    "XaxisType\0xAxisType\0numberOfXticks\0"
    "YAxisType\0yAxisType\0YAxisScaling\0"
    "yAxisScaling\0YaxisLimitsMax_1\0"
    "YaxisLimitsMin_1\0YaxisScalingMax_1\0"
    "axisScaling\0YaxisScalingMin_1\0Style_1\0"
    "curvStyle\0color_1\0YaxisLimitsMax_2\0"
    "YaxisLimitsMin_2\0YaxisScalingMax_2\0"
    "YaxisScalingMin_2\0Style_2\0color_2\0"
    "YaxisLimitsMax_3\0YaxisLimitsMin_3\0"
    "YaxisScalingMax_3\0YaxisScalingMin_3\0"
    "Style_3\0color_3\0YaxisLimitsMax_4\0"
    "YaxisLimitsMin_4\0YaxisScalingMax_4\0"
    "YaxisScalingMin_4\0Style_4\0color_4\0"
    "YaxisLimitsMax_5\0YaxisLimitsMin_5\0"
    "YaxisScalingMax_5\0YaxisScalingMin_5\0"
    "Style_5\0color_5\0YaxisLimitsMax_6\0"
    "YaxisLimitsMin_6\0YaxisScalingMax_6\0"
    "YaxisScalingMin_6\0Style_6\0color_6\0"
    "YaxisLimitsMax_7\0YaxisLimitsMin_7\0"
    "YaxisScalingMax_7\0YaxisScalingMin_7\0"
    "Style_7\0color_7\0foreground\0background\0"
    "scaleColor\0grid\0gridColor\0XaxisEnabled\0"
    "YaxisEnabled\0LegendEnabled\0XaxisSyncGroup\0"
    "Low\0Medium\0High\0Channel\0User\0Lines\0"
    "FillUnder\0Millisecond\0Second\0Minute\0"
    "ValueScale\0TimeScale\0TimeScaleFix\0"
    "linear\0log10\0fixedScale\0autoScale"
};
#undef QT_MOC_LITERAL

static const uint qt_meta_data_caStripPlot[] = {

 // content:
       7,       // revision
       0,       // classname
       0,    0, // classinfo
       5,   14, // methods
      65,   46, // properties
       7,  241, // enums/sets
       0,    0, // constructors
       0,       // flags
       3,       // signalCount

 // signals: name, argc, parameters, tag, flags
       1,    1,   39,    2, 0x06 /* Public */,
       3,    0,   42,    2, 0x06 /* Public */,
       4,    0,   43,    2, 0x06 /* Public */,

 // slots: name, argc, parameters, tag, flags
       5,    0,   44,    2, 0x08 /* Private */,
       6,    0,   45,    2, 0x08 /* Private */,

 // signals: parameters
    QMetaType::Void, QMetaType::QPoint,    2,
    QMetaType::Void,
    QMetaType::Void,

 // slots: parameters
    QMetaType::Void,
    QMetaType::Void,

 // properties: name, type, flags
       7, QMetaType::QBrush, 0x00094103,
       8, QMetaType::Bool, 0x00094103,
       9, QMetaType::QString, 0x00095003,
      10, QMetaType::QString, 0x00095103,
      11, QMetaType::QString, 0x00095103,
      12, QMetaType::QStringList, 0x00085003,
      13, QMetaType::QString, 0x00095003,
      14, 0x80000000 | 14, 0x0009510b,
      15, QMetaType::Double, 0x00095103,
      16, 0x80000000 | 17, 0x0009500b,
      18, 0x80000000 | 19, 0x0009510b,
      20, QMetaType::Int, 0x00095003,
      21, 0x80000000 | 22, 0x0009500b,
      23, 0x80000000 | 24, 0x0009500b,
      25, QMetaType::Double, 0x00095103,
      26, QMetaType::Double, 0x00095103,
      27, 0x80000000 | 28, 0x0009500b,
      29, 0x80000000 | 28, 0x0009500b,
      30, 0x80000000 | 31, 0x0009510b,
      32, QMetaType::QColor, 0x00095103,
      33, QMetaType::Double, 0x00095103,
      34, QMetaType::Double, 0x00095103,
      35, 0x80000000 | 28, 0x0009500b,
      36, 0x80000000 | 28, 0x0009500b,
      37, 0x80000000 | 31, 0x0009510b,
      38, QMetaType::QColor, 0x00095103,
      39, QMetaType::Double, 0x00095103,
      40, QMetaType::Double, 0x00095103,
      41, 0x80000000 | 28, 0x0009500b,
      42, 0x80000000 | 28, 0x0009500b,
      43, 0x80000000 | 31, 0x0009510b,
      44, QMetaType::QColor, 0x00095103,
      45, QMetaType::Double, 0x00095103,
      46, QMetaType::Double, 0x00095103,
      47, 0x80000000 | 28, 0x0009500b,
      48, 0x80000000 | 28, 0x0009500b,
      49, 0x80000000 | 31, 0x0009510b,
      50, QMetaType::QColor, 0x00095103,
      51, QMetaType::Double, 0x00095103,
      52, QMetaType::Double, 0x00095103,
      53, 0x80000000 | 28, 0x0009500b,
      54, 0x80000000 | 28, 0x0009500b,
      55, 0x80000000 | 31, 0x0009510b,
      56, QMetaType::QColor, 0x00095103,
      57, QMetaType::Double, 0x00095103,
      58, QMetaType::Double, 0x00095103,
      59, 0x80000000 | 28, 0x0009500b,
      60, 0x80000000 | 28, 0x0009500b,
      61, 0x80000000 | 31, 0x0009510b,
      62, QMetaType::QColor, 0x00095103,
      63, QMetaType::Double, 0x00095103,
      64, QMetaType::Double, 0x00095103,
      65, 0x80000000 | 28, 0x0009500b,
      66, 0x80000000 | 28, 0x0009500b,
      67, 0x80000000 | 31, 0x0009510b,
      68, QMetaType::QColor, 0x00095103,
      69, QMetaType::QColor, 0x00095103,
      70, QMetaType::QColor, 0x00095103,
      71, QMetaType::QColor, 0x00095103,
      72, QMetaType::Bool, 0x00095103,
      73, QMetaType::QColor, 0x00095103,
      74, QMetaType::Bool, 0x00095103,
      75, QMetaType::Bool, 0x00095103,
      76, QMetaType::Bool, 0x00095103,
      77, QMetaType::Int, 0x00095103,

 // enums: name, flags, count, data
      17, 0x0,    3,  269,
      28, 0x0,    2,  275,
      31, 0x0,    2,  279,
      14, 0x0,    3,  283,
      19, 0x0,    3,  289,
      22, 0x0,    2,  295,
      24, 0x0,    2,  299,

 // enum data: key, value
      78, uint(caStripPlot::Low),
      79, uint(caStripPlot::Medium),
      80, uint(caStripPlot::High),
      81, uint(caStripPlot::Channel),
      82, uint(caStripPlot::User),
      83, uint(caStripPlot::Lines),
      84, uint(caStripPlot::FillUnder),
      85, uint(caStripPlot::Millisecond),
      86, uint(caStripPlot::Second),
      87, uint(caStripPlot::Minute),
      88, uint(caStripPlot::ValueScale),
      89, uint(caStripPlot::TimeScale),
      90, uint(caStripPlot::TimeScaleFix),
      91, uint(caStripPlot::linear),
      92, uint(caStripPlot::log10),
      93, uint(caStripPlot::fixedScale),
      94, uint(caStripPlot::autoScale),

       0        // eod
};

void caStripPlot::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        caStripPlot *_t = static_cast<caStripPlot *>(_o);
        Q_UNUSED(_t)
        switch (_id) {
        case 0: _t->ShowContextMenu((*reinterpret_cast< const QPoint(*)>(_a[1]))); break;
        case 1: _t->update(); break;
        case 2: _t->timerThreadStop(); break;
        case 3: _t->TimeOut(); break;
        case 4: _t->TimeOutThread(); break;
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
        int *result = reinterpret_cast<int *>(_a[0]);
        void **func = reinterpret_cast<void **>(_a[1]);
        {
            typedef void (caStripPlot::*_t)(const QPoint & );
            if (*reinterpret_cast<_t *>(func) == static_cast<_t>(&caStripPlot::ShowContextMenu)) {
                *result = 0;
            }
        }
        {
            typedef void (caStripPlot::*_t)();
            if (*reinterpret_cast<_t *>(func) == static_cast<_t>(&caStripPlot::update)) {
                *result = 1;
            }
        }
        {
            typedef void (caStripPlot::*_t)();
            if (*reinterpret_cast<_t *>(func) == static_cast<_t>(&caStripPlot::timerThreadStop)) {
                *result = 2;
            }
        }
    }
#ifndef QT_NO_PROPERTIES
    else if (_c == QMetaObject::ReadProperty) {
        caStripPlot *_t = static_cast<caStripPlot *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0: *reinterpret_cast< QBrush*>(_v) = _t->canvasBackground(); break;
        case 1: *reinterpret_cast< bool*>(_v) = _t->autoReplot(); break;
        case 2: *reinterpret_cast< QString*>(_v) = _t->getTitlePlot(); break;
        case 3: *reinterpret_cast< QString*>(_v) = _t->getTitleX(); break;
        case 4: *reinterpret_cast< QString*>(_v) = _t->getTitleY(); break;
        case 5: *reinterpret_cast< QStringList*>(_v) = _t->getPVSList(); break;
        case 6: *reinterpret_cast< QString*>(_v) = _t->getPVS(); break;
        case 7: *reinterpret_cast< units*>(_v) = _t->getUnits(); break;
        case 8: *reinterpret_cast< double*>(_v) = _t->getPeriod(); break;
        case 9: *reinterpret_cast< cpuUsage*>(_v) = _t->getUsageCPU(); break;
        case 10: *reinterpret_cast< xAxisType*>(_v) = _t->getXaxisType(); break;
        case 11: *reinterpret_cast< int*>(_v) = _t->getXticks(); break;
        case 12: *reinterpret_cast< yAxisType*>(_v) = _t->getYaxisType(); break;
        case 13: *reinterpret_cast< yAxisScaling*>(_v) = _t->getYaxisScaling(); break;
        case 14: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_1(); break;
        case 15: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_1(); break;
        case 16: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_1(); break;
        case 17: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_1(); break;
        case 18: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_1(); break;
        case 19: *reinterpret_cast< QColor*>(_v) = _t->getColor_1(); break;
        case 20: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_2(); break;
        case 21: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_2(); break;
        case 22: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_2(); break;
        case 23: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_2(); break;
        case 24: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_2(); break;
        case 25: *reinterpret_cast< QColor*>(_v) = _t->getColor_2(); break;
        case 26: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_3(); break;
        case 27: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_3(); break;
        case 28: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_3(); break;
        case 29: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_3(); break;
        case 30: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_3(); break;
        case 31: *reinterpret_cast< QColor*>(_v) = _t->getColor_3(); break;
        case 32: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_4(); break;
        case 33: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_4(); break;
        case 34: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_4(); break;
        case 35: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_4(); break;
        case 36: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_4(); break;
        case 37: *reinterpret_cast< QColor*>(_v) = _t->getColor_4(); break;
        case 38: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_5(); break;
        case 39: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_5(); break;
        case 40: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_5(); break;
        case 41: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_5(); break;
        case 42: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_5(); break;
        case 43: *reinterpret_cast< QColor*>(_v) = _t->getColor_5(); break;
        case 44: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_6(); break;
        case 45: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_6(); break;
        case 46: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_6(); break;
        case 47: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_6(); break;
        case 48: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_6(); break;
        case 49: *reinterpret_cast< QColor*>(_v) = _t->getColor_6(); break;
        case 50: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMax_7(); break;
        case 51: *reinterpret_cast< double*>(_v) = _t->getYaxisLimitsMin_7(); break;
        case 52: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMax_7(); break;
        case 53: *reinterpret_cast< axisScaling*>(_v) = _t->getYscalingMin_7(); break;
        case 54: *reinterpret_cast< curvStyle*>(_v) = _t->getStyle_7(); break;
        case 55: *reinterpret_cast< QColor*>(_v) = _t->getColor_7(); break;
        case 56: *reinterpret_cast< QColor*>(_v) = _t->getForeground(); break;
        case 57: *reinterpret_cast< QColor*>(_v) = _t->getBackground(); break;
        case 58: *reinterpret_cast< QColor*>(_v) = _t->getScaleColor(); break;
        case 59: *reinterpret_cast< bool*>(_v) = _t->getGrid(); break;
        case 60: *reinterpret_cast< QColor*>(_v) = _t->getGridColor(); break;
        case 61: *reinterpret_cast< bool*>(_v) = _t->getXaxisEnabled(); break;
        case 62: *reinterpret_cast< bool*>(_v) = _t->getYaxisEnabled(); break;
        case 63: *reinterpret_cast< bool*>(_v) = _t->getLegendEnabled(); break;
        case 64: *reinterpret_cast< int*>(_v) = _t->getXaxisSyncGroup(); break;
        default: break;
        }
    } else if (_c == QMetaObject::WriteProperty) {
        caStripPlot *_t = static_cast<caStripPlot *>(_o);
        Q_UNUSED(_t)
        void *_v = _a[0];
        switch (_id) {
        case 0: _t->setCanvasBackground(*reinterpret_cast< QBrush*>(_v)); break;
        case 1: _t->setAutoReplot(*reinterpret_cast< bool*>(_v)); break;
        case 2: _t->setTitlePlot(*reinterpret_cast< QString*>(_v)); break;
        case 3: _t->setTitleX(*reinterpret_cast< QString*>(_v)); break;
        case 4: _t->setTitleY(*reinterpret_cast< QString*>(_v)); break;
        case 5: _t->setPVSList(*reinterpret_cast< QStringList*>(_v)); break;
        case 6: _t->setPVS(*reinterpret_cast< QString*>(_v)); break;
        case 7: _t->setUnits(*reinterpret_cast< units*>(_v)); break;
        case 8: _t->setPeriod(*reinterpret_cast< double*>(_v)); break;
        case 9: _t->setUsageCPU(*reinterpret_cast< cpuUsage*>(_v)); break;
        case 10: _t->setXaxisType(*reinterpret_cast< xAxisType*>(_v)); break;
        case 11: _t->setXticks(*reinterpret_cast< int*>(_v)); break;
        case 12: _t->setYaxisType(*reinterpret_cast< yAxisType*>(_v)); break;
        case 13: _t->setYaxisScaling(*reinterpret_cast< yAxisScaling*>(_v)); break;
        case 14: _t->setYaxisLimitsMax_1(*reinterpret_cast< double*>(_v)); break;
        case 15: _t->setYaxisLimitsMin_1(*reinterpret_cast< double*>(_v)); break;
        case 16: _t->setYscalingMax_1(*reinterpret_cast< axisScaling*>(_v)); break;
        case 17: _t->setYscalingMin_1(*reinterpret_cast< axisScaling*>(_v)); break;
        case 18: _t->setStyle_1(*reinterpret_cast< curvStyle*>(_v)); break;
        case 19: _t->setColor_1(*reinterpret_cast< QColor*>(_v)); break;
        case 20: _t->setYaxisLimitsMax_2(*reinterpret_cast< double*>(_v)); break;
        case 21: _t->setYaxisLimitsMin_2(*reinterpret_cast< double*>(_v)); break;
        case 22: _t->setYscalingMax_2(*reinterpret_cast< axisScaling*>(_v)); break;
        case 23: _t->setYscalingMin_2(*reinterpret_cast< axisScaling*>(_v)); break;
        case 24: _t->setStyle_2(*reinterpret_cast< curvStyle*>(_v)); break;
        case 25: _t->setColor_2(*reinterpret_cast< QColor*>(_v)); break;
        case 26: _t->setYaxisLimitsMax_3(*reinterpret_cast< double*>(_v)); break;
        case 27: _t->setYaxisLimitsMin_3(*reinterpret_cast< double*>(_v)); break;
        case 28: _t->setYscalingMax_3(*reinterpret_cast< axisScaling*>(_v)); break;
        case 29: _t->setYscalingMin_3(*reinterpret_cast< axisScaling*>(_v)); break;
        case 30: _t->setStyle_3(*reinterpret_cast< curvStyle*>(_v)); break;
        case 31: _t->setColor_3(*reinterpret_cast< QColor*>(_v)); break;
        case 32: _t->setYaxisLimitsMax_4(*reinterpret_cast< double*>(_v)); break;
        case 33: _t->setYaxisLimitsMin_4(*reinterpret_cast< double*>(_v)); break;
        case 34: _t->setYscalingMax_4(*reinterpret_cast< axisScaling*>(_v)); break;
        case 35: _t->setYscalingMin_4(*reinterpret_cast< axisScaling*>(_v)); break;
        case 36: _t->setStyle_4(*reinterpret_cast< curvStyle*>(_v)); break;
        case 37: _t->setColor_4(*reinterpret_cast< QColor*>(_v)); break;
        case 38: _t->setYaxisLimitsMax_5(*reinterpret_cast< double*>(_v)); break;
        case 39: _t->setYaxisLimitsMin_5(*reinterpret_cast< double*>(_v)); break;
        case 40: _t->setYscalingMax_5(*reinterpret_cast< axisScaling*>(_v)); break;
        case 41: _t->setYscalingMin_5(*reinterpret_cast< axisScaling*>(_v)); break;
        case 42: _t->setStyle_5(*reinterpret_cast< curvStyle*>(_v)); break;
        case 43: _t->setColor_5(*reinterpret_cast< QColor*>(_v)); break;
        case 44: _t->setYaxisLimitsMax_6(*reinterpret_cast< double*>(_v)); break;
        case 45: _t->setYaxisLimitsMin_6(*reinterpret_cast< double*>(_v)); break;
        case 46: _t->setYscalingMax_6(*reinterpret_cast< axisScaling*>(_v)); break;
        case 47: _t->setYscalingMin_6(*reinterpret_cast< axisScaling*>(_v)); break;
        case 48: _t->setStyle_6(*reinterpret_cast< curvStyle*>(_v)); break;
        case 49: _t->setColor_6(*reinterpret_cast< QColor*>(_v)); break;
        case 50: _t->setYaxisLimitsMax_7(*reinterpret_cast< double*>(_v)); break;
        case 51: _t->setYaxisLimitsMin_7(*reinterpret_cast< double*>(_v)); break;
        case 52: _t->setYscalingMax_7(*reinterpret_cast< axisScaling*>(_v)); break;
        case 53: _t->setYscalingMin_7(*reinterpret_cast< axisScaling*>(_v)); break;
        case 54: _t->setStyle_7(*reinterpret_cast< curvStyle*>(_v)); break;
        case 55: _t->setColor_7(*reinterpret_cast< QColor*>(_v)); break;
        case 56: _t->setForeground(*reinterpret_cast< QColor*>(_v)); break;
        case 57: _t->setBackground(*reinterpret_cast< QColor*>(_v)); break;
        case 58: _t->setScaleColor(*reinterpret_cast< QColor*>(_v)); break;
        case 59: _t->setGrid(*reinterpret_cast< bool*>(_v)); break;
        case 60: _t->setGridColor(*reinterpret_cast< QColor*>(_v)); break;
        case 61: _t->setXaxisEnabled(*reinterpret_cast< bool*>(_v)); break;
        case 62: _t->setYaxisEnabled(*reinterpret_cast< bool*>(_v)); break;
        case 63: _t->setLegendEnabled(*reinterpret_cast< bool*>(_v)); break;
        case 64: _t->setXaxisSyncGroup(*reinterpret_cast< int*>(_v)); break;
        default: break;
        }
    } else if (_c == QMetaObject::ResetProperty) {
    }
#endif // QT_NO_PROPERTIES
}

const QMetaObject caStripPlot::staticMetaObject = {
    { &QwtPlot::staticMetaObject, qt_meta_stringdata_caStripPlot.data,
      qt_meta_data_caStripPlot,  qt_static_metacall, Q_NULLPTR, Q_NULLPTR}
};


const QMetaObject *caStripPlot::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *caStripPlot::qt_metacast(const char *_clname)
{
    if (!_clname) return Q_NULLPTR;
    if (!strcmp(_clname, qt_meta_stringdata_caStripPlot.stringdata0))
        return static_cast<void*>(const_cast< caStripPlot*>(this));
    return QwtPlot::qt_metacast(_clname);
}

int caStripPlot::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QwtPlot::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 5)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 5;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 5)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 5;
    }
#ifndef QT_NO_PROPERTIES
   else if (_c == QMetaObject::ReadProperty || _c == QMetaObject::WriteProperty
            || _c == QMetaObject::ResetProperty || _c == QMetaObject::RegisterPropertyMetaType) {
        qt_static_metacall(this, _c, _id, _a);
        _id -= 65;
    } else if (_c == QMetaObject::QueryPropertyDesignable) {
        bool *_b = reinterpret_cast<bool*>(_a[0]);
        switch (_id) {
        case 6: *_b = inactiveButVisible(); break;
        default: break;
        }
        _id -= 65;
    } else if (_c == QMetaObject::QueryPropertyScriptable) {
        _id -= 65;
    } else if (_c == QMetaObject::QueryPropertyStored) {
        _id -= 65;
    } else if (_c == QMetaObject::QueryPropertyEditable) {
        _id -= 65;
    } else if (_c == QMetaObject::QueryPropertyUser) {
        _id -= 65;
    }
#endif // QT_NO_PROPERTIES
    return _id;
}

// SIGNAL 0
void caStripPlot::ShowContextMenu(const QPoint & _t1)
{
    void *_a[] = { Q_NULLPTR, const_cast<void*>(reinterpret_cast<const void*>(&_t1)) };
    QMetaObject::activate(this, &staticMetaObject, 0, _a);
}

// SIGNAL 1
void caStripPlot::update()
{
    QMetaObject::activate(this, &staticMetaObject, 1, Q_NULLPTR);
}

// SIGNAL 2
void caStripPlot::timerThreadStop()
{
    QMetaObject::activate(this, &staticMetaObject, 2, Q_NULLPTR);
}
QT_END_MOC_NAMESPACE
